VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "jsonlib"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit
Option Compare Text

'=======================================================================
' Author:   Peter Ennis
' Date :    Nov 9, 2014
' Comment:  Fork of vba-json project
' GitHub:   https://github.com/peterennis/eJsonVBA/tree/vba-json
' History:  Read basTESTvbajsonlog history, commit messages on GitHub
' License:  This class module is made available with the BSD License
' Ref:      https://code.google.com/p/vba-json/source/detail?r=2
'=======================================================================

Private Const INVALID_RPC_CALL  As Long = 7

Private Const jsonlibVERSION As String = "0.1.6"
Private Const jsonlibVERSION_DATE As String = "December 14, 2014"

Private pParseError As String
Private bDebugEncode As Boolean
Private bDebugState As Boolean
Private bDebugParseKey As Boolean
Private bDebugParseNumber As Boolean
Private bDebugParseObject As Boolean
Private bDebugParseString As Boolean

Private m_SDecimal As String
Private m_SThousand As String
Private m_StrLen As Long
Private m_Str() As Integer
'

Private Sub Class_Initialize()
    Debug.Print , "Class_Initialize"
    bDebugParseKey = False
    bDebugParseNumber = False
    bDebugParseObject = False
    bDebugParseString = True
    bDebugEncode = True
    'Debug.Print , "jsonlibVERSION=" & jsonlibVERSION
    'Debug.Print , "jsonlibVERSION_DATE=" & jsonlibVERSION_DATE
End Sub

Private Sub Class_Terminate()
    Debug.Print , "Class_Terminate"
End Sub

Public Property Get GetParseError() As String
    If bDebugState Then Debug.Print ">>GetParseError"
    GetParseError = pParseError
End Property

Public Property Get ClearParseError() As String
    If bDebugState Then Debug.Print ">>ClearParseError"
    pParseError = vbNullString
    ClearParseError = "pParseError = vbNullString"
End Property

Public Property Get DebugState() As Boolean
    If bDebugState Then Debug.Print ">>DebugState=" & bDebugState
    DebugState = bDebugState
End Property

Public Property Let DebugState(blnDebug As Boolean)
    If bDebugState Then Debug.Print ">>DebugState=" & bDebugState
    bDebugState = blnDebug
End Property

Private Function charView(str As String) As Boolean
    
    Dim i As Long
    Dim iMax As Long
    
    iMax = Len(str)
    For i = 1 To iMax
        If Asc(Mid$(str, i, 1)) >= 33 And Asc(Mid$(str, i, 1)) < 127 Then
            Debug.Print Mid$(str, i, 1);
        Else
            Debug.Print Chr(187) & Mid$(str, i, 1) & ":" & _
                Asc(Mid$(str, i, 1));
        End If
    Next
End Function

'
'   parse string and create JSON object (Dictionary or Collection in VB)
'
Public Function parse(ByRef str As String) As Object

    If bDebugState Then Debug.Print ">>parse"

    m_SDecimal = GetSDecimal
    m_SThousand = GetSThousand

    Dim index As Long
    index = 1

    'Call GenerateStringArray(str)

    pParseError = vbNullString
    '''On Error Resume Next

    Call skipChar(str, index)
    If bDebugParseKey Then Debug.Print , "Function parse", index, Mid(str, index, 1)

    Select Case Mid(str, index, 1)
    Case "{"
        Set parse = parseObject(str, index)
    Case "["
        Set parse = parseArray(str, index)
    Case Else
        pParseError = "str=" & str & " index=" & index & " Invalid JSON"
        Debug.Print , "E1 parse: " & pParseError
        If bDebugState Then
            Call charView(str)
            Debug.Print
        End If
        Exit Function
    End Select

End Function

Private Sub generateStringArray(ByRef str As String)

    If bDebugState Then Debug.Print ">>GenerateStringArray"

    Dim i As Long

    m_StrLen = Len(str)
    ReDim m_Str(1 To m_StrLen)

    For i = 1 To m_StrLen
        m_Str(i) = AscW(Mid$(str, i, 1))
    Next i

End Sub

'
'   parse collection of key/value
'
Private Function parseObject(ByRef str As String, ByRef index As Long) As Object

    On Error GoTo PROC_ERR

    If bDebugState Then Debug.Print ">>parseObject"

    Set parseObject = CreateObject("Scripting.Dictionary")

    Dim sKey As String

    Call skipChar(str, index)

    If Mid(str, index, 1) <> "{" Then
        pParseError = pParseError & "Invalid Object at position " & index & " : " & Mid(str, index)
        Debug.Print , "E2 parseObject: " & pParseError
        If bDebugState Then
            Call charView(str)
            Debug.Print
        End If
        'Err.Raise vbObjectError + 1000, "jsonVBA.parseObject", "E2 Prevent error message loop"
        Exit Function
    End If

    index = index + 1
    If bDebugParseObject Then Debug.Print , "Function parseObject", index, Mid(str, index, 1)

    Do

        Call skipChar(str, index)
        If bDebugParseObject Then Debug.Print , "Function parseObject", index, Mid(str, index, 1)

        If "}" = Mid(str, index, 1) Then
            index = index + 1
            Exit Do
        ElseIf "," = Mid(str, index, 1) Then
            index = index + 1
            Call skipChar(str, index)
        ElseIf index > Len(str) Then
            pParseError = pParseError & "Missing '}' at index " & index
            Debug.Print , "E3 parseObject: " & pParseError
            If bDebugState Then
                Call charView(str)
                Debug.Print
            End If
            Exit Function
        End If

        If ("""" <> Mid(str, index, 1)) And ("'" <> Mid(str, index, 1)) Then
            pParseError = pParseError & "Missing "" or ' at index " & index
            Debug.Print , "E4 parseObject: " & pParseError, Mid(str, 1, index)
            'Stop
            If bDebugState Then
                Call charView(str)
                Debug.Print
            End If
            Exit Function
        End If

        ' add key/value pair
        sKey = parseKey(str, index)
        If bDebugParseObject Then Debug.Print , "sKey=" & sKey, "index=" & index
        'Stop
        
        '''On Error Resume Next
        
        parseObject.Add sKey, parseValue(str, index)
        If Err.Number <> 0 Then
            pParseError = pParseError & Err.Description & ": " & sKey & vbCrLf
            Debug.Print , "E5 parseObject: " & pParseError
            If bDebugState Then
                Call charView(str)
                Debug.Print
            End If
            Exit Function
        End If

    Loop

PROC_EXIT:
    Exit Function

PROC_ERR:
    MsgBox "Err=" & Err & " " & Err.Description, , "parseObject"
    Resume PROC_EXIT

End Function

'
'   parse list
'
Private Function parseArray(ByRef str As String, ByRef index As Long) As Collection

    If bDebugState Then Debug.Print ">>parseArray"

    Set parseArray = New Collection

    Call skipChar(str, index)

    If Mid(str, index, 1) <> "[" Then
        pParseError = pParseError & "Invalid Array at position " & index & " : " + Mid(str, index, 20) & vbCrLf
        Debug.Print , "E6 parseArray: " & pParseError
        If bDebugState Then
            Call charView(str)
            Debug.Print
        End If
        Exit Function
    End If

    index = index + 1

    Do

        Call skipChar(str, index)

        If "]" = Mid(str, index, 1) Then
            index = index + 1
            Exit Do
        ElseIf "," = Mid(str, index, 1) Then
            index = index + 1
            Call skipChar(str, index)
        ElseIf index > Len(str) Then
            pParseError = pParseError & "Missing ']' at index " & index
            Debug.Print , "E7 parseArray: " & pParseError
            If bDebugState Then
                Call charView(str)
                Debug.Print
            End If
            Exit Function
        End If

        ' add value
        '''On Error Resume Next
        parseArray.Add parseValue(str, index)
        If Err.Number <> 0 Then
            pParseError = pParseError & Err.Description & ": " & Mid(str, index, 20) & vbCrLf
            Debug.Print , "E8 parseArray: " & pParseError
            If bDebugState Then
                Call charView(str)
                Debug.Print
            End If
            Exit Function
        End If

    Loop

End Function

'
'   parse string / number / object / array / true / false / null
'
Private Function parseValue(ByRef str As String, ByRef index As Long) As Variant

    If bDebugState Then Debug.Print ">>parseValue"

    On Error GoTo PROC_EXIT

    Call skipChar(str, index)

    Select Case Mid(str, index, 1)
        Case "{"
            Set parseValue = parseObject(str, index)
        Case "["
            Set parseValue = parseArray(str, index)
        Case """", "'"
            parseValue = parseString(str, index)
        Case "t", "f"
            parseValue = parseBoolean(str, index)
            If parseValue = "Error" Then
                Debug.Print , "parseValue Boolean = ""Error""", index
                'Err.Raise vbObjectError + 1001, "jsonVBA.parseValue", "parseValue boolean error"
                'Exit Function
            End If
        Case "n"
            parseValue = parseNull(str, index)
        Case Else
            parseValue = parseNumber(str, index)
            If parseValue = "Error" Then
                Debug.Print , "parseValue Number = ""Error""", index
                'Err.Raise vbObjectError + 1001, "jsonVBA.parseValue", "parseValue boolean error"
                'Exit Function
            End If
    End Select

PROC_EXIT:
    Exit Function

PROC_ERR:
    MsgBox "Err=" & Err & " " & Err.Description, , "parseValue"
    Resume PROC_EXIT

End Function

'
'   parse string
'
Private Function parseString(ByRef str As String, ByRef index As Long) As String

    If bDebugState Then Debug.Print ">>parseString"

    Dim quote As String
    Dim char As String
    Dim code As String

    Call skipChar(str, index)

    quote = Mid(str, index, 1)
    'Debug.Print , "quote=" & quote, index
    index = index + 1

    Do While index > 0 And index <= Len(str)
        char = Mid(str, index, 1)
        Select Case (char)
        Case "\"
            index = index + 1
            char = Mid(str, index, 1)
            Select Case (char)
                Case "\"
                    parseString = parseString & "\"
                    index = index + 1
                Case """", "/", "'", "\\"
                    parseString = parseString & char
                    index = index + 1
                Case "b"
                    parseString = parseString & vbBack
                    index = index + 1
                Case "f"
                    parseString = parseString & vbFormFeed
                    index = index + 1
                Case "n"
                    parseString = parseString & vbLf
                    index = index + 1
                Case "r"
                    parseString = parseString & vbCr
                    index = index + 1
                Case "t"
                    parseString = parseString & vbTab
                    index = index + 1
                Case "u"
                    index = index + 1
                    code = Mid(str, index, 4)
                    parseString = parseString & ChrW(Val("&h" + code))
                    index = index + 4
            End Select
        Case quote
            index = index + 1
            Exit Function
        Case Else
            parseString = parseString & char
            index = index + 1
        End Select
    Loop

End Function

'
'   parse number
'
Private Function parseNumber(ByRef str As String, ByRef index As Long)

    If bDebugState Then Debug.Print ">>parseNumber"

    Dim myValue As String
    Dim char As String

    'Debug.Print "parseNumber", str

    Call skipChar(str, index)

    'Debug.Print "m_StrLen=" & m_StrLen
    'Debug.Print "Len(str)=" & Len(str)
    
    Do While index > 0 And index <= Len(str)
        char = Mid(str, index, 1)
        If bDebugParseNumber Then Debug.Print , "char=" & char
        If InStr("+-0123456789.eE", char) Then
            myValue = myValue & char
            index = index + 1
            If index > 200 Then
                Debug.Print "STOP"
                Stop
            End If
        Else
'            'check what is the grouping separator
'            If Not m_SDecimal = "." Then
'                myValue = Replace(myValue, ".", m_SDecimal)
'                Debug.Print "SD", myValue
'            End If
'
'            If m_SThousand = "." Then
'                myValue = Replace(myValue, ".", m_SDecimal)
'                Debug.Print "ST", myValue
'            End If
'
            Debug.Print , "myValue=" & myValue
            If IsNull(myValue) Or myValue = vbNullString Then
                pParseError = pParseError & "Number expected at index " & index & " : " + Mid(str, index, 20) & vbCrLf
                Debug.Print , "E9 parseBoolean: " & pParseError
                'Stop
                If bDebugState Then
                    Call charView(str)
                    Debug.Print
                End If
                parseNumber = "Error"
                index = Len(str)
            Else
                parseNumber = CDec(myValue)
            End If
            Exit Function
        End If
    Loop

End Function

'
'   parse true / false
'
Private Function parseBoolean(ByRef str As String, ByRef index As Long) As String

    If bDebugState Then Debug.Print ">>parseBoolean"

    On Error GoTo PROC_ERR:

    Call skipChar(str, index)

    If Mid(str, index, 4) = "true" Then
        parseBoolean = "True"
        index = index + 4
    ElseIf Mid(str, index, 5) = "false" Then
        parseBoolean = "False"
        index = index + 5
    Else
        pParseError = pParseError & Err.Description & " - Invalid Boolean at position " & index & _
                        " : " & Mid(str, index) & vbCrLf
        Debug.Print , "E10 parseBoolean: " & pParseError
        'Stop
        If bDebugState Then
            Call charView(str)
            Debug.Print
        End If
        parseBoolean = "Error"
        index = Len(str)
        'Err.Raise vbObjectError + 1000, "jsonVBA.parseBoolean", "E9 Prevent error message loop"
        'Exit Function
    End If

PROC_EXIT:
    Exit Function

PROC_ERR:
    MsgBox "Err=" & Err & " " & Err.Description, , "parseBoolean"
    Resume Next

End Function

'
'   parse null
'
Private Function parseNull(ByRef str As String, ByRef index As Long)

    If bDebugState Then Debug.Print ">>parseNull"

    Call skipChar(str, index)

    If Mid(str, index, 4) = "null" Then
        parseNull = Null
        index = index + 4
    Else
        pParseError = pParseError & Err.Description & " - Invalid Null value at position " & index & _
                        " : " & Mid(str, index) & vbCrLf
        Debug.Print , "E11 parseNull: " & pParseError
        If bDebugState Then
            Call charView(str)
            Debug.Print
        End If
        Exit Function
    End If

End Function

Private Function parseKey(ByRef str As String, ByRef index As Long) As String

    If bDebugState Then Debug.Print ">>parseKey"

    Dim dquote As Boolean
    Dim squote As Boolean
    Dim char As String

    Call skipChar(str, index)

    Do While index > 0 And index <= Len(str)
        char = Mid(str, index, 1)
        If bDebugParseKey Then Debug.Print , "Function parseKey=" & parseKey, index, char
        Select Case (char)
            Case """"
                dquote = Not dquote
                index = index + 1
                If Not dquote Then
                    Call skipChar(str, index)
                    If Mid(str, index, 1) <> ":" Then
                        pParseError = pParseError & Err.Description & " - Invalid Key value at position " & index & _
                                    " : " & parseKey & vbCrLf
                    Debug.Print , "E12 parseKey: " & pParseError
                    If bDebugState Then
                        Call charView(str)
                        Debug.Print
                    End If
                    Exit Function
                    End If
                End If
            Case "'"
                squote = Not squote
                index = index + 1
                If Not squote Then
                    Call skipChar(str, index)
                    If Mid(str, index, 1) <> ":" Then
                        pParseError = pParseError & Err.Description & " - Invalid Key value at position " & index & _
                                    " : " & parseKey & vbCrLf
                        Debug.Print , "E13 parseKey: " & pParseError
                        If bDebugState Then
                            Call charView(str)
                            Debug.Print
                        End If
                        Exit Function
                    End If
                End If
            Case ":"
                If Not dquote And Not squote Then
                    index = index + 1
                    Exit Do
                ElseIf dquote And Not squote Then
                    parseKey = parseKey & char
                    index = index + 1
                End If

'                index = index + 1
'                If Not dquote And Not squote Then
'                    Exit Do
'                ElseIf dquote And Not squote Then
'                    parseKey = parseKey & char
'                    index = index + 1
'                Else
'                    parseKey = parseKey & char
'                End If
            Case Else
                If InStr(vbCrLf & vbCr & vbLf & vbTab, char) Then
                Else
                    parseKey = parseKey & char
                End If
                index = index + 1
        End Select
    Loop

End Function

'
'   skip special character
'
'Private Sub skipChar(ByRef str As String, ByRef index As Long)
'Public Sub skipChar(ByRef str As String, ByRef index As Long)
Friend Sub skipChar(ByRef str As String, ByRef index As Long)

    If bDebugState Then Debug.Print ">>skipChar"

    While index > 0 And index <= Len(str) And InStr(vbCrLf & vbCr & vbLf & vbTab & " ", Mid(str, index, 1))
        index = index + 1
    Wend
Exit Sub

    Dim bComment As Boolean
    Dim bStartComment As Boolean
    Dim bLongComment As Boolean
    Do While index > 0 And index <= Len(str)
        Select Case Mid(str, index, 1)
            Case vbCr, vbLf
                If Not bLongComment Then
                    bStartComment = False
                    bComment = False
                End If
         
            Case vbTab, " ", "(", ")"

            Case "/"
                If Not bLongComment Then
                    If bStartComment Then
                        bStartComment = False
                        bComment = True
                    Else
                        bStartComment = True
                        bComment = False
                        bLongComment = False
                    End If
                Else
                    If bStartComment Then
                        bLongComment = False
                        bStartComment = False
                        bComment = False
                End If
            End If

        Case "*"
            If bStartComment Then
                bStartComment = False
                bComment = True
                bLongComment = True
            Else
                bStartComment = True
            End If

        Case Else
            If Not bComment Then
                Exit Do
            End If
        End Select

        index = index + 1
    Loop

End Sub

Public Function toString(ByRef obj As Variant) As String

    If bDebugState Then Debug.Print ">>toString"

    Select Case VarType(obj)
        Case vbNull
            toString = "null"
        Case vbDate
            toString = """" & CStr(obj) & """"
        Case vbString
            If bDebugParseString Then Debug.Print "toString vbString"
            toString = """" & encode(obj) & """"
        Case vbObject
            Dim bFI As Boolean
            Dim i As Integer
            bFI = True
            If TypeName(obj) = "Dictionary" Then
                toString = toString & "{"
                Dim keys As Variant
                keys = obj.keys
                For i = 0 To obj.Count - 1
                    If bFI Then bFI = False Else toString = toString & ","
                    Dim key As String
                    key = keys(i)
                    toString = toString & """" & key & """:" & toString(obj(key))
                Next i
                toString = toString & "}"
            ElseIf TypeName(obj) = "Collection" Then
                toString = toString & "["
                Dim myValue As Variant
                For Each myValue In obj
                    If bFI Then bFI = False Else toString = toString & ","
                    toString = toString & toString(myValue)
                Next myValue
                toString = toString & "]"
            End If
        Case vbBoolean
            If obj Then toString = "true" Else toString = "false"
        Case vbVariant, vbArray, vbArray + vbVariant
            Dim sEB
            toString = multiArray(obj, 1, "", sEB)
        Case Else
            Debug.Print obj
            toString = Replace(obj, ",", ".")
    End Select

End Function

Private Function encode(str As Variant) As String

    If bDebugState Then Debug.Print ">>encode"

    Dim i As Integer
    Dim j As Integer
    Dim aL1 As Variant
    Dim aL2 As Variant
    Dim a As String
    Dim c As String
    Dim p As Boolean

    aL1 = Array(&H22, &H5C, &H2F, &H8, &HC, &HA, &HD, &H9)
                '34,    92,   47,   8,  12,  10,  13,   9
                ' ",     \,   /,   BS,  FF,  LF,  CR,  HT
                ' Ref: http://www.ascii-code.com
    aL2 = Array(&H22, &H5C, &H2F, &H62, &H66, &H6E, &H72, &H74)
    For i = 1 To Len(str)
        p = True
        c = Mid(str, i, 1)
        For j = 0 To 7
            If c = Chr(aL1(j)) Then
                If bDebugEncode Then Debug.Print , c;
                encode = encode & "\" & Chr(aL2(j))
                p = False
                Exit For
            End If
        Next

        If p Then
            a = AscW(c)
            If a > 31 And a < 127 Then
                encode = encode & c
            ElseIf a > -1 Or a < 65535 Then
                encode = encode & "\u" & String(4 - Len(Hex(a)), "0") & Hex(a)
            End If
        End If
    Next

End Function

Private Function multiArray(aBD, iBC, sPS, ByRef sPT)   ' Array BoDy, Integer BaseCount, String PoSition

    If bDebugState Then Debug.Print ">>multiArray"

    Dim iDU As Integer  ' Integer DimensionUBound
    Dim iDL As Integer  ' Integer DimensionLBound
    Dim i As Integer

    On Error Resume Next
    iDL = LBound(aBD, iBC) ' <<< Error here if on error commented out - NEED FIX
    iDU = UBound(aBD, iBC)

    Dim sPB1 As String  ' String PointBuffer1
    Dim sPB2 As String  ' String PointBuffer2

    If Err.Number = 9 Then
        sPB1 = sPT & sPS
        For i = 1 To Len(sPB1)
            If i <> 1 Then sPB2 = sPB2 & ","
            sPB2 = sPB2 & Mid(sPB1, i, 1)
        Next
'        multiArray = multiArray & toString(Eval("aBD(" & sPB2 & ")"))
        multiArray = multiArray & toString(aBD(sPB2))
    Else
        sPT = sPT & sPS
        multiArray = multiArray & "["
        For i = iDL To iDU
            multiArray = multiArray & multiArray(aBD, iBC + 1, i, sPT)
            If i < iDU Then multiArray = multiArray & ","
        Next
        multiArray = multiArray & "]"
        sPT = Left(sPT, iBC - 2)
    End If
    Err.Clear

End Function

Private Function jsonRpcCall(url As String, methName As String, args(), Optional user As String, Optional pwd As String) As Object

    If bDebugState Then Debug.Print ">>JsonRpcCall"

    Dim r As Object
    Dim cli As Object
    Dim pText As String
    Static reqId As Integer

    reqId = reqId + 1

    Set r = CreateObject("Scripting.Dictionary")
    r("jsonrpc") = "2.0"
    r("method") = methName
    r("params") = args
    r("id") = reqId

    pText = toString(r)

    Set cli = CreateObject("MSXML2.XMLHTTP.6.0")
    ' Set cli = New MSXML2.XMLHTTP60
    If Len(user) > 0 Then   ' If Not IsMissing(user) Then
        cli.Open "POST", url, False, user, pwd
    Else
        cli.Open "POST", url, False
    End If
    cli.setRequestHeader "Content-Type", "application/json"
    cli.Send pText

    If cli.Status <> 200 Then
        Err.Raise vbObjectError + INVALID_RPC_CALL + cli.Status, , cli.statusText
    End If

    Set r = parse(cli.responseText)
    Set cli = Nothing

    If r("id") <> reqId Then Err.Raise vbObjectError + INVALID_RPC_CALL, , "Bad Response id"

    If r.Exists("error") Or Not r.Exists("result") Then
        Err.Raise vbObjectError + INVALID_RPC_CALL, , "Json-Rpc Response error: " & r("error")("message")
    End If

    If Not r.Exists("result") Then Err.Raise vbObjectError + INVALID_RPC_CALL, , "Bad Response, missing result"

    Set jsonRpcCall = r("result")

End Function

Public Function toUnicode(str As String) As String

    If bDebugState Then Debug.Print ">>toUnicode"

'    Dim x As Long
'    Dim uStr As New cStringBuilder
'    Dim uChrCode As Integer
'
'    For x = 1 To Len(str)
'        uChrCode = Asc(Mid(str, x, 1))
'        Select Case uChrCode
'            Case 8:   ' backspace
'                uStr.Append "\b"
'            Case 9: ' tab
'                uStr.Append "\t"
'            Case 10:  ' line feed
'                uStr.Append "\n"
'            Case 12:  ' formfeed
'                uStr.Append "\f"
'            Case 13: ' carriage return
'                uStr.Append "\r"
'            Case 34: ' quote
'                uStr.Append "\"""
'            Case 39:  ' apostrophe
'                uStr.Append "\'"
'            Case 92: ' backslash
'                uStr.Append "\\"
'            Case 123, 125:  ' "{" and "}"
'                uStr.Append ("\u" & Right("0000" & Hex(uChrCode), 4))
'            Case Is < 32, Is > 127: ' non-ascii characters
'                uStr.Append ("\u" & Right("0000" & Hex(uChrCode), 4))
'            Case Else
'                uStr.Append Chr$(uChrCode)
'        End Select
'    Next
'    toUnicode = uStr.toString
'    Exit Function

End Function
